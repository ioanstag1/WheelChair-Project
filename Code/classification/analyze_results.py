import os
import glob
import warnings
import re
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt

# Use Agg backend to prevent GUI windows from opening (essential for servers/Colab)
matplotlib.use("Agg")
warnings.filterwarnings("ignore")

# ============================================================
# 1. CONFIGURATION
# ============================================================

# Path to the original dataset (required only to retrieve feature names)
ORIGINAL_FEATURES_CSV = 'Combined_Features_CLEANED.csv' 

# Directory containing the results (summary_*.csv files generated by the main script)
RESULTS_DIR = 'Results/Brazil_Poland/Combined_Features_CLEANED/'

# Verify that the results directory exists
if not os.path.exists(RESULTS_DIR):
    raise FileNotFoundError(f"[ERROR] Directory {RESULTS_DIR} not found.")

print(f"[INFO] Reading results from: {RESULTS_DIR}")

# ============================================================
# 2. LOAD AND MERGE SUMMARY FILES
# ============================================================
all_files = glob.glob(os.path.join(RESULTS_DIR, "summary_*.csv"))
print(f"[INFO] Found {len(all_files)} summary files.")

dfs = []
for f in all_files:
    # Skip empty files
    if os.path.getsize(f) == 0:
        print(f"[WARNING] Skipping empty file: {f}")
        continue

    df = pd.read_csv(f)
    fname = os.path.basename(f).replace("summary_", "").replace(".csv", "")

    # Extract strategy name and k value from filename (e.g., svm_w_k10)
    # Regex looks for text followed by '_k' and a number
    match = re.match(r"([a-zA-Z_]+)_k(\d+)", fname)
    if match:
        strategy, k = match.groups()
        df["strategy"] = strategy
        df["k"] = int(k)
    else:
        # Fallback if filename format does not match expected pattern
        df["strategy"] = fname
        df["k"] = None

    dfs.append(df)

if not dfs:
    raise ValueError("[ERROR] No valid data found for analysis.")

# Combine all individual result files into one master DataFrame
all_df = pd.concat(dfs, ignore_index=True)
print(f"[SUCCESS] Combined {len(all_df)} rows of results.")

# ============================================================
# 3. IDENTIFY TOP MODELS (TOP 10 PER STRATEGY)
# ============================================================
# Sort by Strategy -> Balanced Accuracy (Desc) -> AUC (Desc)
top10_per_strategy = (
    all_df.sort_values(by=["strategy", "bal_acc_mean", "auc"], ascending=[True, False, False])
    .groupby("strategy")
    .head(10)
)

print("\nTop 10 Models per Feature Selection Strategy:")
for strat, sub in top10_per_strategy.groupby("strategy"):
    print(f"\n--- {strat.upper()} ---")
    print(sub[["model", "k", "bal_acc_mean", "auc"]].round(3))

# ============================================================
# 4. GLOBAL BEST MODEL
# ============================================================
# Identify the single best performing model across all experiments
best_overall = all_df.sort_values(by=["bal_acc_mean", "auc"], ascending=[False, False]).iloc[0]

cols_to_show = ["model", "strategy", "k", "bal_acc_mean", "auc"]
best_row = best_overall[cols_to_show].copy()

# Round values for cleaner display
for c in ["bal_acc_mean", "auc"]:
    best_row[c] = round(float(best_row[c]), 3)

print("\nGlobal Best Model:")
print(best_row)

# ============================================================
# 5. BEST CONFIGURATION PER MODEL TYPE
# ============================================================
print("\n[INFO] Finding best configuration per classifier type...")

best_per_model = (
    all_df.sort_values(["model", "bal_acc_mean", "auc"], ascending=[True, False, False])
    .groupby("model")
    .first()
    .reset_index()
)

print("\nBest configuration per model type:")
print(best_per_model[["model", "strategy", "k", "bal_acc_mean", "auc"]])

# ============================================================
# 6. BEST RESULT PER STRATEGY + MODEL COMBINATION
# ============================================================
best_model_strategy = (
    all_df.sort_values(by=["bal_acc_mean", "auc"], ascending=[False, False])
    .groupby(["strategy", "model"])
    .first()
    .reset_index()
)

# Save detailed report to CSV
best_path = os.path.join(RESULTS_DIR, "best_results_per_model_per_strategy.csv")
best_model_strategy.to_csv(best_path, index=False)
print(f"[SUCCESS] Saved detailed report to: {best_path}")

# ============================================================
# 7. VISUALIZATION: PERFORMANCE HEATMAPS
# ============================================================
# Create Pivot Tables for plotting
pivot_acc = best_model_strategy.pivot(index="model", columns="strategy", values="bal_acc_mean")
pivot_auc = best_model_strategy.pivot(index="model", columns="strategy", values="auc")

# Initialize Plot
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))

# Heatmap 1: Balanced Accuracy
sns.heatmap(pivot_acc, annot=True, fmt=".3f", cmap="YlGnBu", ax=ax1, cbar_kws={'label': 'Balanced Accuracy'})
ax1.set_title("Best Balanced Accuracy\n(Model vs Strategy)")
ax1.set_xlabel("Strategy")
ax1.set_ylabel("Model")

# Heatmap 2: AUC
sns.heatmap(pivot_auc, annot=True, fmt=".3f", cmap="YlGnBu", ax=ax2, cbar_kws={'label': 'AUC'})
ax2.set_title("Best AUC\n(Model vs Strategy)")
ax2.set_xlabel("Strategy")
ax2.set_ylabel("Model")

plt.tight_layout()
heatmap_path = os.path.join(RESULTS_DIR, "heatmap_performance.png")
plt.savefig(heatmap_path, dpi=300)
plt.close()
print(f"[SUCCESS] Saved heatmap: {heatmap_path}")

# ============================================================
# 8. VISUALIZATION: ACCURACY vs. NUMBER OF FEATURES (k)
# ============================================================
print("\n[INFO] Generating performance vs. feature count plots...")

# Ensure 'k' is numeric for plotting
all_df["k"] = pd.to_numeric(all_df["k"], errors='coerce')

# Drop rows where 'k' is missing (e.g., baseline models with all features)
plot_df = all_df.dropna(subset=["k"])

# Get unique classifiers
models = plot_df["model"].unique()

# Loop through each model and save a SEPARATE plot
for model in models:
    # Filter data for the specific model
    subset = plot_df[plot_df["model"] == model]
    
    plt.figure(figsize=(8, 6))
    
    # Plot line
    sns.lineplot(
        data=subset,
        x="k",
        y="bal_acc_mean",
        hue="strategy",     # Different color for each strategy
        style="strategy",   # Different line style for B&W printing compatibility
        markers=True,
        dashes=False,
        linewidth=2.5,
        errorbar=None       # Clean lines, removes confidence interval shading
    )
    
    # Styling
    plt.title(f"Classifier Performance: {model}", fontsize=16, fontweight='bold')
    plt.xlabel("Number of Selected Features (k)", fontsize=14)
    plt.ylabel("Balanced Accuracy", fontsize=14)
    plt.legend(title="Selection Strategy", fontsize=12, title_fontsize=12)
    plt.grid(True, linestyle="--", alpha=0.6)
    plt.tight_layout()
    
    # Save individual file
    filename = f"PLOT_Accuracy_vs_k_{model}.png"
    path_plot = os.path.join(RESULTS_DIR, filename)
    plt.savefig(path_plot, dpi=300)
    plt.close()
    
    print(f"   [SUCCESS] Saved plot for {model}: {filename}")

# ============================================================
# 9. FEATURE IMPORTANCE VISUALIZATION (FOR TOP MODELS)
# ============================================================
# Load feature names for readability in plots
if os.path.exists(ORIGINAL_FEATURES_CSV):
    df_feats = pd.read_csv(ORIGINAL_FEATURES_CSV)
    # Exclude non-numeric and label columns to isolate feature names
    X_temp = df_feats.select_dtypes(include=[np.number]).drop(columns=["label", "binary_label", "patient"], errors="ignore")
    feature_names = list(X_temp.columns)
    print(f"[INFO] Loaded {len(feature_names)} feature names.")
else:
    print("[WARNING] Original feature CSV not found. Using generic names.")
    feature_names = []

# --- Helper Functions for Plotting ---
def plot_feature_hist(df_plot, model_name, strat, k, output_dir):
    """Generates and saves a horizontal bar plot of selected features."""
    plt.figure(figsize=(10, max(6, len(df_plot) * 0.25)))
    sns.barplot(y="feature_name", x=model_name, data=df_plot, palette="viridis")
    plt.title(f"Feature Selection Frequency\nModel: {model_name} | {strat} (k={k})")
    plt.xlabel("Selection Count")
    plt.ylabel("Feature")
    plt.grid(axis='x', alpha=0.3)
    plt.tight_layout()
    
    path = os.path.join(output_dir, f"PLOT_features_{model_name}_{strat}_k{k}.png")
    plt.savefig(path, dpi=300)
    plt.close()
    print(f"   [SUCCESS] Saved feature plot: {os.path.basename(path)}")

def extract_features(model, strat, k, output_dir):
    """Loads feature frequency data for a specific model configuration."""
    freq_file = os.path.join(output_dir, f"feature_frequency_{strat}_k{k}_ALL.csv")
    
    if not os.path.exists(freq_file):
        print(f"   [WARNING] Frequency file missing for {model} ({strat}_k{k})")
        return None
        
    df_freq = pd.read_csv(freq_file)
    if model not in df_freq.columns:
        return None
        
    # Keep only relevant columns and sort
    df_freq = df_freq[["feature_index", model]].dropna()
    df_freq = df_freq.sort_values(by=model, ascending=False)
    
    # Map indices to actual feature names (standard 0-based indexing)
    if feature_names:
        df_freq["feature_name"] = df_freq["feature_index"].apply(
            lambda i: feature_names[int(float(i))] if 0 <= int(float(i)) < len(feature_names) else f"Feat_{int(float(i))}"
        )
    else:
        df_freq["feature_name"] = df_freq["feature_index"].apply(lambda i: f"Feat_{int(float(i))}")
        
    return df_freq

# --- Generate Plots for Best Models ---
print("\n[INFO] Generating Feature Frequency Plots for Top Models...")
all_feature_stats = []

for _, row in best_per_model.iterrows():
    mdl = row["model"]
    strat = row["strategy"]
    k_val = int(row["k"])
    
    print(f"-> Analyzing Features for: {mdl} ({strat}, k={k_val})")
    
    df_feat = extract_features(mdl, strat, k_val, RESULTS_DIR)
    
    if df_feat is not None:
        # Save feature list to CSV
        csv_name = os.path.join(RESULTS_DIR, f"features_list_{mdl}_{strat}_k{k_val}.csv")
        df_feat.to_csv(csv_name, index=False)
        
        # Generate Plot
        plot_feature_hist(df_feat, mdl, strat, k_val, RESULTS_DIR)
        
        # Append to summary list
        df_feat["model"] = mdl
        df_feat["strategy"] = strat
        df_feat["k"] = k_val
        all_feature_stats.append(df_feat)

# --- Save Master Feature Summary ---
if all_feature_stats:
    grand_summary = pd.concat(all_feature_stats, ignore_index=True)
    grand_path = os.path.join(RESULTS_DIR, "ALL_MODELS_FEATURE_SUMMARY.csv")
    grand_summary.to_csv(grand_path, index=False)
    print(f"\n[SUCCESS] Saved Global Feature Summary: {grand_path}")

print("\n[COMPLETE] Analysis Finished Successfully.")